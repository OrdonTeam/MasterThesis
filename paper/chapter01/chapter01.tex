\chapter{Wstęp}

W dzisiejszych czasach gromadzimy ogromne ilości danych.
W związku obserwujemy rozwój dziedziny eksploracji i analizy danych
Pewna część tych problemów jest ściśle związana z koniecznością precyzyjnego wyodrębniania właściwych danych z ogromnej masy danych niepotrzebnych
Szczególnym przypadkiem analizy danych są dane binarne, reprezentowane wektorami binarnymi o stosunkowo dużej liczbie bitów,
a małej liczbie danych które trzeba wyselekcjonować.
Jeżeli na dodatek zbiór danych selekcjonowanych podlega częstym zmianom,
to strukturę sprzętową takich układów trzeba często zmieniać.
W związku z tym rozwiązaniem tego problemu są struktury FPGA z wbudowanymi pamięciami ROM.
Ale kolejną barierą w realizacji tych układów są ograniczenia w nadmiernej pojemności pamięci ROM o dużej liczbie wejść – np. 40,
co byłoby wymagane przy selekcji niewielkiej liczby wektorów (wzorców), np. 10.
Można jednak przypuszczać, że binarna tablica takich wektorów: 40 kolumn oznaczanych $x_1,…,x_{40}$ i 10 wierszy zawiera kolumny $x_i, x_j, ..., x_k$,
które ustawione obok siebie reprezentują różne liczby binarne \cite{sasao-workshop}.
Zwykle takich kolumn jest wyraźnie mniej od liczby zmiennych (bitów) wektorów selekcjonowanych.
Zatem jedną z metod rozwiązania zadania selekcji jest redukcja argumentów,
a cały problem jest określany mianem syntezy funkcji generowania indeksów.

Zagadnienie redukcji argumentów jest tożsame z problemem redukcji atrybutów.
W tym ujęciu zagadnienie to było badane bardzo intensywnie \cite{fast-algorithm, efektywna-procedura, new-reduction, steinbach-posthoff, skowron-rauszer, slezak, novel-method}.
Jednym z najbardziej znanych algorytmów redukcji atrybutów jest algorytm zastosowany w systemie RSES \cite{rses}.
Algorytm ten został skutecznie usprawniony w pracy inżynierskiej \cite{efektywna-procedura},
natomiast w ramach niniejszej pracy stworzono realizację obliczającą jedno rozwiązanie [rozdz. ??].
Analogiczne zadanie podjęto w zespole prof. Sasao,
a w referacie \cite{sasao-workshop} znaczenie redukcji zasygnalizowano informacją,
iż opracowanie algorytmu redukcji jest jednym z najważniejszych zadań.

Drugim aktualnym zagadnieniem syntezy logicznej w projektowaniu generatorów adresu jest dekompozycja liniowa.
Przez dekompozycję liniową rozumie się dekompozycję $F = H(G1, G2, ...,  X)$,
w której składowymi dekompozycji G są dwuargumentowe funkcje $EXOR$:
\begin{equation}
F = H (x_i \oplus x_j, x_k \oplus x_l, ..., X)
\end{equation}
Do najbardziej znanych algorytmów dekompozycji liniowej stosowanej w generatorach adresów należy algorytm s-min \cite{sasao-recent, sasao-s-min}.
W artykule \cite{redukcja-kompresja} wykazano, że algorytm s-min jest mało skuteczny i zaproponowano całkowicie inne ujęcie tego zagadnienia.
W niniejszej pracy metodykę tę przystosowano do heurystycznych obliczeń funkcji generowania indeksów.
Cechą charakterystyczną tej propozycji jest zastosowanie twierdzenia wiążącego dekompozycję liniową z tzw. zbiorem rozróżnialności [rozdz. ??].
W rezultacie opracowano metodykę oraz algorytm (i jego implementację) do heurystycznych obliczeń praktycznych funkcji indeksowania [rozdz. …].
Przykłady takich dekompozycji podano w rozdz. ??.

\section{Problem generowania indeksów w technice cyfrowej}

Problem generowania indeksów (adresu) dotyczy szczególnie tej podgrupy problemów czasu rzeczywistego,
w których warunki podejmowania decyzji są zmienne w czasie.
Sztandarowym zastosowaniem algorytmów generowania indeksów jest obsługa pakietów w routerach IP.
Spotykamy się tam z problemami filtrowania ruchu z niepożądanych adresów (firewall) lub wybierania portów wyjściowych (routing).
W obu przypadkach znajdują zastosowanie struktury programowalne FPGA lub EEPROM
ze względu na połączenie szybkości działania porównywalnej z rozwiązaniami ASIC oraz elastyczności jak w przypadku rozwiązań programowych.
Wyzwania,
jakie są stawiane przed algorytmami generowania indeksów,
są związane częstymi zmianami danych.Indeksy często muszą być generowane w czasie rzeczywistym wraz ze zmianami danych.
Ponadto ze względu na dużą liczbę argumentów,
które muszą być brane pod uwagę (32 bity - adresy IPv4, 48 bitów - adresy mac),
wymagane są optymalizacje pozwalające wykorzystywać pamięci dostępne w strukturach programowalnych.

\section{Cel pracy - do usunięcia}

Celem pracy było opracowanie algorytmu generowania indeksów na podstawie istniejących algorytmów z dziedziny syntezy logicznej
oraz porównanie nowej metody z wynikami aktualnych prac badawczych z zakresu generowania indeksów.
Wyniki obliczeń dla przykładu referencyjnego,
przeprowadzone przed przystąpieniem do właściwych badań,
potwierdziły konkurencyjność algorytmu opartego na połączeniu redukcji argumentów oraz dekompozycji liniowej.
W porównaniu z aktualnymi artykułami Profesora Sasao,
nowa metoda pozwala na zmniejszenie zużycia zasobów potrzebnych do realizacji funkcji w strukturach programowalnych.
Tym samym pozwala wykorzysywać mniejsze i tańsze urządzenie do rozwiązywania tych samych problemów,
albo na obsługę przoblemów, które wcześniej były zbyt zlożone,
za pomocą do tej pory używanego sprzętu komputerowego.

%%% Previous chapter 2.
\chapter{Przedstawienie problemu}
(O popularności problemu)

\section{Zastosowania}
- Tablica trasowania
- Terminal access controller
- Memory patch circuit
- Skanowanie wirusów
- Dystrybucja adresów IP
- Skanowanie wirusów
- Wykrywanie niepożądanych danych
- Konwersja kodów

\subsection{Tablica trasowania}
W Internecie powszechne jest zagadnienie znajdowania ścieżek dla pakietów IP.
Każdy węzeł sieci przechowuje informacje dotyczące wyboru trasy dla przychodzących pakietów.
Dla każdego przechowywanego adresu IP w tablicy adresów znajduje się indeks pamięci, w którym przechowywane są wszystkie szczegóły.
Liczba adresów w takiej pamięci wynosi nierzadko nawet 40 tysięcy.
Jako że adresy IP są reprezentowane przez 32 bity, tyle właśnie jest argumentów funkcji.
Dodatkowo w wielu routerach mamy do czynienia z dynamicznymi protokołami trasowania, które wymagają częstych zmian w tablicy adresów.
Jest to w związku z tym bardzo dobry przykład zastosowania funkcji generowania indeksów.

\section{Generowanie indeksów}

Problem generowania indeksów można porównać do potrzeby znajdowania wzorca w strumieniu danych.
Inaczej mówiąc mając próbkę danych w postaci pojedynczego wektora boolowskiego, musimy stwierdzić czy jest on zgodny z którymś z wektorów poszukiwanych w strumieniu.
Dla niewielkich wektorów można ten problem rozwiązać tablicując wynik dla wszystkich możliwy wektorów binarnych.
Wiąże się to z dużym zużyciem pamięci.
Przykładowo przy funkcji o 6 argumentach wszystkich wektorów binarnych jest 64 (26).
Jeżeli spośród wszystkich wektorów poszukiwanych jest np. 6 konkretnych, wtedy dla każdego z 64 wektorów musielibyśmy przechować 3 bity ($\log_26$).
Dla takiego przykładu minimalna potrzebna pamięć to 192 bity.
Jednak dla mechanizmu znajdowania sygnatur wirusów składającego się z 1.3 miliona poszukiwanych wektorów o 40 argumentach, taka pamięć miałaby rozmiar 21 terabitów.
\begin{multline} \\
2^{40} \cdot \log_2 1300000 = \\
= 2^{10} \cdot 2^{10} \cdot 2^{10} \cdot 2^{10} \cdot 21 = \\
=21 \cdot 2^{10} \cdot 2^{10} \cdot 2^{10} k = \\
=21 \cdot 2^{10} \cdot 2^{10} M = \\
=21 \cdot 2^{10} G = \\
=21 [Tbit] \\
\end{multline}

\section{Algorytm Sasao}
Rozwiązanie problemu nadmiernej pojemności pamięci o $n$ wejściach adresowych przy wykrywaniu $k$ wekrtorów indeksowanych ($k<<2^n$),
spośród $2^n$ możliwych wektorów wejściowych,
zaproponował Sasao \cite{sasao-workshop, sasao-recent, sasao-s-min, sasao-synthesis}.
Istotą tego rozwiązania jest
\begin{enumerate}[label=\alph*)]
\item Obliczanie minimalnej liczby argumentów potrzebnych do reprezentacji funkcji specyfikowanej $k$ wektorami $n$-bitowymi,
\item Dekompozycja liniowa funkcji obliczonej w punkcie a)
\end{enumerate}

Z punktu widzenie syntezy funkcji generowania indeksów propozycja Sasao jest jak najbardziej prawidłowa. Niestety zastosowany w tej metodzie algorytm redukcji argumentów,
jak też prcedura obliczania dekompozycji liniowej nie są najskuteczniejsze.

%Rozwiązanie problemu rosnącej pamięci zaproponował Profesor Tsutomu Sasao.
%Częścią jego pomysłu jest ograniczenie liczby argumentów potrzebnych do adresowania pamięci.
%Idea stojąca za takim rozwiązaniem bierze się stąd, że do rozróżnienia 1.3 miliona wektorów z poprzedniego przykładu może wystarczyć jedynie 21 bitów.
%Gdyby udało się faktycznie zredukować liczbę wejść z 40 do 21 bitów, rozmiar pamięci zmniejszyłby się z 21 terabitów do 42 megabitów.
%\begin{multline} \\
%2^{21} \cdot \log_2 1300000 = \\
%= 2^{10} \cdot 2^{10} \cdot 2 \cdot 21 = 42 [Mbit] \\
%\end{multline}
%Zmniejszenie rozmiaru pamięci głównej nie pozwalałoby na jednoznaczne określenie czy dany wektor jest wektorem poszukiwanym.
%Wskazywałoby jedynie numer jedynego wiersza z poszukiwanych, który ma szansę być identyczny z wektorem sprawdzanym.
%Potrzebne jest zatem przechowanie wszystkich kompletnych wektorów poszukiwanych w drugiej pamięci.
%W naszym przykładzie wektorów jest 1,3 miliona i każdy ma 40 bitów.
%Rozmiar dodatkowej pamięci wyniósłby w takim razie 50 megabitów.
%
%W zaproponowanym rozwiązaniu częścią, która ma największe znaczenie na rozmiar niezbędnej pamięci,
%jest wyznaczenie funkcji pozwalającej na jak największe zmniejszenie liczby wejść do głównej pamięci.
%\textbf{(Wymaga uzupełnienia z artykułem)} W pracy Profesora Sasao dla konkretnej funkcji ten wynik pozwala na ograniczenie wejść z \textbf{N do X}.
%Sposobem zaproponowanym w pracy uzyskujemy zmniejszenie z \textbf{N do Y}.
%Warto zauważyć, że zmniejszenie o jeden argument powoduje dwukrotne zmniejszenie wymaganej pamięci.
