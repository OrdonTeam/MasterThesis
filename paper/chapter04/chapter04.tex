\chapter{Badania}
\label{chapter:research}

W rozdziale tym zostały zaprezentowane wyniki badań przeprowadzone dla przykładowych funkcji referencyjnych.
Wszystkie funkcjie opisane w tym rozdziale znajdują się w załącznikach niniejszej pracy dyplomowej.

\section{Filtr f5}

Przykładem potwierdzającym skuteczność algorytmu opracowanego w ramach niniejszej pracy
może być układ arytmetyki rozproszonej [2] filtru f5 [3].
Reprezentacja tego układu za pomocą w pełni określonych funkcji boolowskich
jest opisana tablicą o 11 zmiennych wejściowych i 11 wyjściach.
Implementacja tego układu [7] w strukturze Virtex-7 wykonana za pomocą programu Vivado 2015.4.2
wymaga zastosowania 531 komórek (330 6-wejściowych, 86 5-wejściowych; pozostałe 4, 3 i 2-wejściowe).
Opracowany algorytm redukcji i kompresji argumentów (dalej nazywany algorytmem RedKomp)
redukuje tę funkcję do 7 argumentów,
umożliwiając jej realizację
(wykonywana w tej samej strukturze programem Vivado)
w strukturze zajmującej 9 komórek 6-wejściowych oraz po jednej 5, 4 i 2-wejściowej.

\section{Przykład Sasao}

Eksperyment dotyczy generatora indeksów analizowanego w referacie Sasao [8].
Dla funkcji tej prof. Sasao wyznaczył 5-argumentowy redukt – Tab. Xb.
Program RedKomp wyznaczył redukt 4-argumentowy Tab. Xc.

Rezultatem tego wyniku jest możliwość zrealizowania tej
funkcji w strukturze zaproponowanej w referacie Sasao (rys. 1) [9],
zbudowanej z dwóch pamięci: pamięć głównej i pomocniczej,
które mają zaledwie 4 wejścia adresowe.

W~strukturze tej blok selekcji zmiennych wybiera spośród wszystkich zmiennych podzbiór $X_1$,
reprezentujący minimalną liczbę zmiennych realizowanej Funkcji Generowania Indeksów (FGI).
Liczność reduktu jest r.
Jest to jednocześnie liczba wejść do pamięci głównej.
Na wyjściach pamięci głównej pojawia się indeks wektora wejściowego $X = X_1 \cup X_2$.
Jest on reprezentowany wektorem binarnym o liczbie bitów $p = log_2 (k+1)$.
Indeks ten jest poprawnym indeksem wektora wejściowego wtedy,
jeżeli jest to wektor rejestrowany.
I tylko wtedy indeks ten pojawi sie na wyjściach generatora.
W przypadku,
gdy wektor wejściowy nie jest wektorem rejestrowanym na wyjściach generator pojawi się 0.
Sprawdzenie,
czy wyjścia pamięci głównej reprezentują poprawny indeks jest realizowane w pamięci pomocniczej i komparatorze.
W pamięci pomocniczej są zapisane wektory reprezentowane zmiennymi należącymi do zbioru $X_2$.
Wektory te są podawane na wejście komparatora i porównywane z rzeczywistym wektorem $X_2$ podawanym na drugie wejście komparatora.
Oczywiście wektor pobrany z pamięci pomocniczej będzie różny od rzeczywistego wektora $X_2$ w przypadku,
gdy nie należy on do wektora rejestrowanego.
Wtedy komparator sygnałem wyjściowym 0 zablokuje pojawienie się na wyjściach bramy AND wektora wytworzonego w pamięci głównej.

\section{Permutacje 1 z 10}

Kolejny eksperyment dotyczy funkcji ,,1 z 10'' analizowanej w artykule [10].
Ponieważ funkcję tę można zredukować do 9 zmiennych,
bez zmiennej $x_2$ - w Tab. 6 podano tę funkcję przy oznaczeniach $a_1, ..., a_9$.

Przy tych oznaczeniach Sasao, stosując algorytm 2-Min obliczył dekompozycję [10]:

Następnie po zastosowaniu algorytmu 3-Min indeksowanie zostało poprawione do wektorów 5-bitowych [10]:

Rezultat uzyskany metodą RedKomp jest 4-bitowy (patrz Dodatek):

\section{Permutacje 2 z 16}

Eksperyment 4 dotyczy funkcji ,,2 z 16''.
Dekompozycja liniowa tej funkcji obliczana algorytmem 2-Min oraz 3-Min [10] tworzy układ o 11 wejściach.
Liczby wejść do poszczególnych bramek XOR nie są podane.
Program RedKomp umożliwia realizację tej funkcji na pamięci o 9 wejściach adresowych.
Poszczególne wejścia y1 do y9 tej pamięci są następującymi funkcjami EXOR:
\begin{multline} \\
y1 = x7 \oplus x1 \oplus x2, \\
y2 = x10 \oplus x2 \oplus x3, \\
y3 = x13 \oplus x6 \oplus x7, \\
y4 = x14 \oplus x9 \oplus x10, \\
y5 = x9 \oplus x10 \oplus x12 \oplus x13, \\
y6 = x0 \oplus x1 \oplus x3 \oplus x4, \\
y7 = x3 \oplus x4 \oplus x5 \oplus x6, \\
y8 = x5 \oplus x6 \oplus x8 \oplus x9, \\
y9 = x8 \oplus x9 \oplus x11 \oplus x12. \\
\end{multline}
